import { 
  Document, 
  Packer, 
  Paragraph, 
  TextRun, 
  HeadingLevel,
  AlignmentType,
  BorderStyle,
  Footer,
  PageNumber,
  NumberFormat,
} from 'docx';
import { UpdateItem, UpdateCategory, DocumentTemplate } from './types';

interface DocumentSection {
  title: string;
  items: UpdateItem[];
}

/**
 * Group updates into sections for document generation
 */
function groupUpdatesForDocument(updates: UpdateItem[]): DocumentSection[] {
  const sections: DocumentSection[] = [];
  
  // Filter out noise
  const relevantUpdates = updates.filter(u => u.category !== 'Noise');
  
  // High Priority section
  const highPriority = relevantUpdates.filter(u => u.priority === 'High');
  if (highPriority.length > 0) {
    sections.push({ title: 'High Priority', items: highPriority });
  }
  
  // Protocol Changes
  const protocols = relevantUpdates.filter(
    u => u.category === 'Protocol' && u.priority !== 'High'
  );
  if (protocols.length > 0) {
    sections.push({ title: 'Protocol Changes', items: protocols });
  }
  
  // Incidents
  const incidents = relevantUpdates.filter(
    u => u.category === 'Incident' && u.priority !== 'High'
  );
  if (incidents.length > 0) {
    sections.push({ title: 'Incidents', items: incidents });
  }
  
  // Announcements
  const announcements = relevantUpdates.filter(
    u => u.category === 'Announcement' && u.priority !== 'High'
  );
  if (announcements.length > 0) {
    sections.push({ title: 'Announcements', items: announcements });
  }
  
  // Reminders
  const reminders = relevantUpdates.filter(u => u.category === 'Reminder');
  if (reminders.length > 0) {
    sections.push({ title: 'Reminders', items: reminders });
  }
  
  // FYI
  const fyis = relevantUpdates.filter(u => u.category === 'FYI');
  if (fyis.length > 0) {
    sections.push({ title: 'FYI / General Updates', items: fyis });
  }
  
  // Staffing (for weekly)
  const staffing = relevantUpdates.filter(u => u.category === 'Staffing/OOO');
  if (staffing.length > 0) {
    sections.push({ title: 'Staffing Notes', items: staffing });
  }
  
  return sections;
}

/**
 * Get template title based on template type
 */
function getTemplateTitle(template: DocumentTemplate, date?: string): string {
  const dateStr = date || new Date().toLocaleDateString();
  
  switch (template) {
    case 'Daily IC Update':
      return `IC Team Daily Update - ${dateStr}`;
    case 'Weekly IC Summary':
      return `IC Team Weekly Summary - ${dateStr}`;
    case 'Leadership Digest':
      return `Leadership Digest - ${dateStr}`;
    default:
      return `IC Team Updates - ${dateStr}`;
  }
}

/**
 * Generate Markdown content from updates
 */
export function generateMarkdown(
  updates: UpdateItem[], 
  template: DocumentTemplate,
  date?: string
): string {
  const sections = groupUpdatesForDocument(updates);
  const title = getTemplateTitle(template, date);
  
  let md = `# ${title}\n\n`;
  
  if (sections.length === 0) {
    md += '*No significant updates to report.*\n';
    return md;
  }
  
  for (const section of sections) {
    md += `## ${section.title}\n\n`;
    
    for (const item of section.items) {
      const ownerInfo = item.owner && item.timestamp_text 
        ? ` _(${item.owner}, ${item.timestamp_text})_` 
        : item.owner 
          ? ` _(${item.owner})_`
          : '';
      
      md += `- **${item.title}**${ownerInfo}\n`;
      md += `  ${item.summary}\n`;
      
      if (item.links.length > 0) {
        md += `  Links: ${item.links.join(', ')}\n`;
      }
      
      md += '\n';
    }
  }
  
  md += '---\n\n';
  md += '*Generated by IC Updates*\n';
  
  return md;
}

/**
 * Create a DOCX document from updates
 */
export async function generateDocx(
  updates: UpdateItem[],
  template: DocumentTemplate,
  date?: string
): Promise<Blob> {
  const sections = groupUpdatesForDocument(updates);
  const title = getTemplateTitle(template, date);
  
  const children: Paragraph[] = [];
  
  // Title
  children.push(
    new Paragraph({
      text: title,
      heading: HeadingLevel.TITLE,
      alignment: AlignmentType.CENTER,
      spacing: { after: 400 },
    })
  );
  
  // Horizontal line after title
  children.push(
    new Paragraph({
      border: {
        bottom: {
          color: '999999',
          space: 1,
          style: BorderStyle.SINGLE,
          size: 6,
        },
      },
      spacing: { after: 400 },
    })
  );
  
  if (sections.length === 0) {
    children.push(
      new Paragraph({
        children: [
          new TextRun({
            text: 'No significant updates to report.',
            italics: true,
          }),
        ],
      })
    );
  } else {
    for (const section of sections) {
      // Section heading
      children.push(
        new Paragraph({
          text: section.title,
          heading: HeadingLevel.HEADING_1,
          spacing: { before: 400, after: 200 },
        })
      );
      
      // Items as bullet points
      for (const item of section.items) {
        const ownerInfo = item.owner && item.timestamp_text 
          ? ` (${item.owner}, ${item.timestamp_text})` 
          : item.owner 
            ? ` (${item.owner})`
            : '';
        
        // Title line
        children.push(
          new Paragraph({
            bullet: { level: 0 },
            children: [
              new TextRun({
                text: item.title,
                bold: true,
              }),
              new TextRun({
                text: ownerInfo,
                italics: true,
                color: '666666',
              }),
            ],
          })
        );
        
        // Summary
        children.push(
          new Paragraph({
            children: [
              new TextRun({
                text: item.summary,
              }),
            ],
            indent: { left: 720 },
            spacing: { after: 100 },
          })
        );
        
        // Links if any
        if (item.links.length > 0) {
          children.push(
            new Paragraph({
              children: [
                new TextRun({
                  text: 'Links: ',
                  bold: true,
                  size: 20,
                }),
                new TextRun({
                  text: item.links.join(', '),
                  size: 20,
                  color: '0066CC',
                }),
              ],
              indent: { left: 720 },
              spacing: { after: 200 },
            })
          );
        }
      }
    }
  }
  
  const doc = new Document({
    sections: [
      {
        properties: {},
        children,
        footers: {
          default: new Footer({
            children: [
              new Paragraph({
                alignment: AlignmentType.CENTER,
                children: [
                  new TextRun({
                    text: 'Generated by IC Updates | Page ',
                    size: 18,
                    color: '999999',
                  }),
                  new TextRun({
                    children: [PageNumber.CURRENT],
                    size: 18,
                    color: '999999',
                  }),
                ],
              }),
            ],
          }),
        },
      },
    ],
  });
  
  return await Packer.toBlob(doc);
}

/**
 * Download a file to the user's computer
 */
export function downloadFile(blob: Blob, filename: string): void {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

/**
 * Download markdown as .md file
 */
export function downloadMarkdown(content: string, filename: string): void {
  const blob = new Blob([content], { type: 'text/markdown' });
  downloadFile(blob, filename);
}

/**
 * Copy text to clipboard
 */
export async function copyToClipboard(text: string): Promise<boolean> {
  try {
    await navigator.clipboard.writeText(text);
    return true;
  } catch (error) {
    console.error('Failed to copy to clipboard:', error);
    return false;
  }
}

